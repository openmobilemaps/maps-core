// AUTOGENERATED FILE - DO NOT MODIFY!
// This file was generated by Djinni from core.djinni

package io.openmobilemaps.mapscore.kmp

import kotlin.experimental.ExperimentalObjCName
import kotlin.native.ObjCName

@OptIn(ExperimentalObjCName::class)
@ObjCName("KMMapCameraInterface", exact = true)
actual class KMMapCameraInterface actual constructor(
    internal val nativeHandle: Any,
) {
    private val native = nativeHandle as MapCoreSharedModule.MCMapCameraInterface

    actual fun freeze(freeze: Boolean) {
        native.freeze(freeze)
    }

    actual fun moveToCenterPositionZoom(centerPosition: KMCoord, zoom: Double, animated: Boolean) {
        native.moveToCenterPositionZoom(centerPosition.asPlatform(), zoom, animated)
    }

    actual fun moveToCenterPosition(centerPosition: KMCoord, animated: Boolean) {
        native.moveToCenterPosition(centerPosition.asPlatform(), animated)
    }

    actual fun moveToBoundingBox(boundingBox: KMRectCoord, paddingPc: Float, animated: Boolean, minZoom: Double?, maxZoom: Double?) {
        native.moveToBoundingBox(boundingBox.asPlatform(), paddingPc, animated, minZoom?.let { platform.Foundation.NSNumber(double = it) }, maxZoom?.let { platform.Foundation.NSNumber(double = it) })
    }

    actual fun getCenterPosition(): KMCoord {
        val result = native.getCenterPosition()
        return (result as MapCoreSharedModule.MCCoord).asKmp()
    }

    actual fun setZoom(zoom: Double, animated: Boolean) {
        native.setZoom(zoom, animated)
    }

    actual fun getZoom(): Double {
        val result = native.getZoom()
        return result
    }

    actual fun setRotation(angle: Float, animated: Boolean) {
        native.setRotation(angle, animated)
    }

    actual fun getRotation(): Float {
        val result = native.getRotation()
        return result
    }

    actual fun setMinZoom(minZoom: Double) {
        native.setMinZoom(minZoom)
    }

    actual fun setMaxZoom(maxZoom: Double) {
        native.setMaxZoom(maxZoom)
    }

    actual fun getMinZoom(): Double {
        val result = native.getMinZoom()
        return result
    }

    actual fun getMaxZoom(): Double {
        val result = native.getMaxZoom()
        return result
    }

    actual fun setBounds(bounds: KMRectCoord) {
        native.setBounds(bounds.asPlatform())
    }

    actual fun getBounds(): KMRectCoord {
        val result = native.getBounds()
        return (result as MapCoreSharedModule.MCRectCoord).asKmp()
    }

    actual fun isInBounds(coords: KMCoord): Boolean {
        val result = native.isInBounds(coords.asPlatform())
        return result
    }

    actual fun setPaddingLeft(padding: Float) {
        native.setPaddingLeft(padding)
    }

    actual fun setPaddingRight(padding: Float) {
        native.setPaddingRight(padding)
    }

    actual fun setPaddingTop(padding: Float) {
        native.setPaddingTop(padding)
    }

    actual fun setPaddingBottom(padding: Float) {
        native.setPaddingBottom(padding)
    }

    actual fun getVisibleRect(): KMRectCoord {
        val result = native.getVisibleRect()
        return (result as MapCoreSharedModule.MCRectCoord).asKmp()
    }

    actual fun getPaddingAdjustedVisibleRect(): KMRectCoord {
        val result = native.getPaddingAdjustedVisibleRect()
        return (result as MapCoreSharedModule.MCRectCoord).asKmp()
    }

    actual fun getScreenDensityPpi(): Float {
        val result = native.getScreenDensityPpi()
        return result
    }

    actual fun update() {
        native.update()
    }

    actual fun getInvariantModelMatrix(coordinate: KMCoord, scaleInvariant: Boolean, rotationInvariant: Boolean): ArrayList<Float> {
        val result = native.getInvariantModelMatrix(coordinate.asPlatform(), scaleInvariant, rotationInvariant)
        return ArrayList(((result as? List<*>)?.map { (it as platform.Foundation.NSNumber).floatValue } ?: (0 until (result as platform.Foundation.NSArray).count.toInt()).map { idx -> ((result as platform.Foundation.NSArray).objectAtIndex(idx.toULong()) as platform.Foundation.NSNumber).floatValue }))
    }

    actual fun addListener(listener: KMMapCameraListenerInterface) {
        native.addListener(listener.asPlatform())
    }

    actual fun removeListener(listener: KMMapCameraListenerInterface) {
        native.removeListener(listener.asPlatform())
    }

    actual fun notifyListenerBoundsChange() {
        native.notifyListenerBoundsChange()
    }

    actual fun coordFromScreenPosition(posScreen: KMVec2F): KMCoord {
        val result = native.coordFromScreenPosition(posScreen.asPlatform())
        return (result as MapCoreSharedModule.MCCoord).asKmp()
    }

    actual fun coordFromScreenPositionZoom(posScreen: KMVec2F, zoom: Float): KMCoord {
        val result = native.coordFromScreenPositionZoom(posScreen.asPlatform(), zoom)
        return (result as MapCoreSharedModule.MCCoord).asKmp()
    }

    actual fun screenPosFromCoord(coord: KMCoord): KMVec2F {
        val result = native.screenPosFromCoord(coord.asPlatform())
        return (result as MapCoreSharedModule.MCVec2F).asKmp()
    }

    actual fun screenPosFromCoordZoom(coord: KMCoord, zoom: Float): KMVec2F {
        val result = native.screenPosFromCoordZoom(coord.asPlatform(), zoom)
        return (result as MapCoreSharedModule.MCVec2F).asKmp()
    }

    actual fun mapUnitsFromPixels(distancePx: Double): Double {
        val result = native.mapUnitsFromPixels(distancePx)
        return result
    }

    actual fun getScalingFactor(): Double {
        val result = native.getScalingFactor()
        return result
    }

    actual fun coordIsVisibleOnScreen(coord: KMCoord, paddingPc: Float): Boolean {
        val result = native.coordIsVisibleOnScreen(coord.asPlatform(), paddingPc)
        return result
    }

    actual fun setRotationEnabled(enabled: Boolean) {
        native.setRotationEnabled(enabled)
    }

    actual fun setSnapToNorthEnabled(enabled: Boolean) {
        native.setSnapToNorthEnabled(enabled)
    }

    actual fun setBoundsRestrictWholeVisibleRect(enabled: Boolean) {
        native.setBoundsRestrictWholeVisibleRect(enabled)
    }

    actual fun asCameraInterface(): KMCameraInterface {
        val result = native.asCameraInterface()
        return requireNotNull((result as MapCoreSharedModule.MCCameraInterfaceProtocol)).asKmp()
    }

    actual fun getLastVpMatrixD(): ArrayList<Double>? {
        val result = native.getLastVpMatrixD()
        return result?.let { ArrayList(((it as? List<*>)?.map { (it as platform.Foundation.NSNumber).doubleValue } ?: (0 until (it as platform.Foundation.NSArray).count.toInt()).map { idx -> ((it as platform.Foundation.NSArray).objectAtIndex(idx.toULong()) as platform.Foundation.NSNumber).doubleValue })) }
    }

    actual fun getLastVpMatrix(): ArrayList<Float>? {
        val result = native.getLastVpMatrix()
        return result?.let { ArrayList(((it as? List<*>)?.map { (it as platform.Foundation.NSNumber).floatValue } ?: (0 until (it as platform.Foundation.NSArray).count.toInt()).map { idx -> ((it as platform.Foundation.NSArray).objectAtIndex(idx.toULong()) as platform.Foundation.NSNumber).floatValue })) }
    }

    actual fun getLastInverseVpMatrix(): ArrayList<Float>? {
        val result = native.getLastInverseVpMatrix()
        return result?.let { ArrayList(((it as? List<*>)?.map { (it as platform.Foundation.NSNumber).floatValue } ?: (0 until (it as platform.Foundation.NSArray).count.toInt()).map { idx -> ((it as platform.Foundation.NSArray).objectAtIndex(idx.toULong()) as platform.Foundation.NSNumber).floatValue })) }
    }

    actual fun getLastVpMatrixViewBounds(): KMRectCoord? {
        val result = native.getLastVpMatrixViewBounds()
        return result?.let { (it as MapCoreSharedModule.MCRectCoord).asKmp() }
    }

    actual fun getLastVpMatrixRotation(): Float? {
        val result = native.getLastVpMatrixRotation()
        return result?.let { (it as platform.Foundation.NSNumber).floatValue }
    }

    actual fun getLastVpMatrixZoom(): Float? {
        val result = native.getLastVpMatrixZoom()
        return result?.let { (it as platform.Foundation.NSNumber).floatValue }
    }

    actual fun getLastCameraPosition(): KMVec3D? {
        val result = native.getLastCameraPosition()
        return result?.let { (it as MapCoreSharedModule.MCVec3D).asKmp() }
    }

    actual fun asMapCamera3d(): KMMapCamera3dInterface? {
        val result = native.asMapCamera3d()
        return result?.let { requireNotNull((it as MapCoreSharedModule.MCMapCamera3dInterface)).asKmp() }
    }

    actual companion object
    {

        actual fun create(mapInterface: KMMapInterface, screenDensityPpi: Float, is3D: Boolean): KMMapCameraInterface {
            val result = MapCoreSharedModule.MCMapCameraInterface.create(mapInterface.asPlatform(), screenDensityPpi, is3D)
            return requireNotNull((result as MapCoreSharedModule.MCMapCameraInterface)).asKmp()
        }
    }
}

internal fun KMMapCameraInterface.asPlatform(): MapCoreSharedModule.MCMapCameraInterface = nativeHandle as MapCoreSharedModule.MCMapCameraInterface
internal fun MapCoreSharedModule.MCMapCameraInterface.asKmp(): KMMapCameraInterface = KMMapCameraInterface(this)
