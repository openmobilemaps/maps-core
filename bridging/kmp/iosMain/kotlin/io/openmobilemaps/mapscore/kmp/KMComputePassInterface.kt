// AUTOGENERATED FILE - DO NOT MODIFY!
// This file was generated by Djinni from core.djinni

@file:Suppress("RedundantCast", "RedundantCallOfConversionMethod", "USELESS_CAST")

package io.openmobilemaps.mapscore.kmp

import kotlin.experimental.ExperimentalObjCName
import kotlin.native.ObjCName
import platform.darwin.NSObject

@OptIn(ExperimentalObjCName::class)
@ObjCName("KMComputePassInterface", exact = true)
actual interface KMComputePassInterface
{

    actual fun getComputeObjects(): ArrayList<KMComputeObjectInterface>
}

private class KMComputePassInterfacePlatformWrapper(internal val nativeHandle: MapCoreSharedModule.MCComputePassInterfaceProtocol) : KMComputePassInterface
{

    override fun getComputeObjects(): ArrayList<KMComputeObjectInterface> {
        val result = nativeHandle.getComputeObjects()
        return ArrayList(((result as? List<*>)?.map { requireNotNull((it as MapCoreSharedModule.MCComputeObjectInterfaceProtocol)).asKmp() } ?: (0 until (result as platform.Foundation.NSArray).count.toInt()).map { idx -> requireNotNull(((result as platform.Foundation.NSArray).objectAtIndex(idx.toULong()) as MapCoreSharedModule.MCComputeObjectInterfaceProtocol)).asKmp() }))
    }
}

private class KMComputePassInterfacePlatformProxy(private val delegate: KMComputePassInterface) : NSObject(), MapCoreSharedModule.MCComputePassInterfaceProtocol
{

    override fun getComputeObjects(): List<*> {
        val result = delegate.getComputeObjects()
        return ArrayList(result.map { it.asPlatform() })
    }
}

internal fun KMComputePassInterface.asPlatform(): MapCoreSharedModule.MCComputePassInterfaceProtocol = when (this) {
    is KMComputePassInterfacePlatformWrapper -> this.nativeHandle
    else -> KMComputePassInterfacePlatformProxy(this)
}
internal fun MapCoreSharedModule.MCComputePassInterfaceProtocol.asKmp(): KMComputePassInterface = KMComputePassInterfacePlatformWrapper(this)
