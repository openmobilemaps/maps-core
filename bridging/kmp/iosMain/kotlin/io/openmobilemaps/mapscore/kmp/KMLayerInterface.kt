// AUTOGENERATED FILE - DO NOT MODIFY!
// This file was generated by Djinni from core.djinni

@file:Suppress("RedundantCast", "RedundantCallOfConversionMethod", "USELESS_CAST")

package io.openmobilemaps.mapscore.kmp

import kotlin.experimental.ExperimentalObjCName
import kotlin.native.ObjCName
import platform.darwin.NSObject

@OptIn(ExperimentalObjCName::class)
@ObjCName("KMLayerInterface", exact = true)
actual interface KMLayerInterface
{

    actual fun setMaskingObject(maskingObject: KMMaskingObjectInterface?)

    actual fun update()

    actual fun buildRenderPasses(): ArrayList<KMRenderPassInterface>

    actual fun buildComputePasses(): ArrayList<KMComputePassInterface>

    actual fun onAdded(mapInterface: KMMapInterface, layerIndex: Int)

    actual fun onRemoved()

    actual fun pause()

    actual fun resume()

    actual fun hide()

    actual fun show()

    actual fun setAlpha(alpha: Float)

    actual fun getAlpha(): Float

    actual fun setScissorRect(scissorRect: KMRectI?)

    actual fun isReadyToRenderOffscreen(): KMLayerReadyState

    actual fun enableAnimations(enabled: Boolean)

    actual fun setErrorManager(errorManager: KMErrorManager)

    actual fun forceReload()

    actual fun setPrimaryRenderTarget(target: KMRenderTargetInterface?)
}

private class KMLayerInterfacePlatformWrapper(internal val nativeHandle: MapCoreSharedModule.MCLayerInterfaceProtocol) : KMLayerInterface
{

    override fun setMaskingObject(maskingObject: KMMaskingObjectInterface?) {
        nativeHandle.setMaskingObject(maskingObject?.let { it.asPlatform() })
    }

    override fun update() {
        nativeHandle.update()
    }

    override fun buildRenderPasses(): ArrayList<KMRenderPassInterface> {
        val result = nativeHandle.buildRenderPasses()
        return ArrayList(((result as? List<*>)?.map { (it as MapCoreSharedModule.MCRenderPassInterfaceProtocol).asKmp() } ?: (0 until (result as platform.Foundation.NSArray).count.toInt()).map { idx -> ((result as platform.Foundation.NSArray).objectAtIndex(idx.toULong()) as MapCoreSharedModule.MCRenderPassInterfaceProtocol).asKmp() }))
    }

    override fun buildComputePasses(): ArrayList<KMComputePassInterface> {
        val result = nativeHandle.buildComputePasses()
        return ArrayList(((result as? List<*>)?.map { (it as MapCoreSharedModule.MCComputePassInterfaceProtocol).asKmp() } ?: (0 until (result as platform.Foundation.NSArray).count.toInt()).map { idx -> ((result as platform.Foundation.NSArray).objectAtIndex(idx.toULong()) as MapCoreSharedModule.MCComputePassInterfaceProtocol).asKmp() }))
    }

    override fun onAdded(mapInterface: KMMapInterface, layerIndex: Int) {
        nativeHandle.onAdded(mapInterface.asPlatform(), layerIndex)
    }

    override fun onRemoved() {
        nativeHandle.onRemoved()
    }

    override fun pause() {
        nativeHandle.pause()
    }

    override fun resume() {
        nativeHandle.resume()
    }

    override fun hide() {
        nativeHandle.hide()
    }

    override fun show() {
        nativeHandle.show()
    }

    override fun setAlpha(alpha: Float) {
        nativeHandle.setAlpha(alpha)
    }

    override fun getAlpha(): Float {
        val result = nativeHandle.getAlpha()
        return result
    }

    override fun setScissorRect(scissorRect: KMRectI?) {
        nativeHandle.setScissorRect(scissorRect?.let { it.asPlatform() })
    }

    override fun isReadyToRenderOffscreen(): KMLayerReadyState {
        val result = nativeHandle.isReadyToRenderOffscreen()
        return KMLayerReadyState.fromPlatform((result as MapCoreSharedModule.MCLayerReadyState))
    }

    override fun enableAnimations(enabled: Boolean) {
        nativeHandle.enableAnimations(enabled)
    }

    override fun setErrorManager(errorManager: KMErrorManager) {
        nativeHandle.setErrorManager(errorManager.asPlatform())
    }

    override fun forceReload() {
        nativeHandle.forceReload()
    }

    override fun setPrimaryRenderTarget(target: KMRenderTargetInterface?) {
        nativeHandle.setPrimaryRenderTarget(target?.let { it.asPlatform() })
    }
}

private class KMLayerInterfacePlatformProxy(private val delegate: KMLayerInterface) : NSObject(), MapCoreSharedModule.MCLayerInterfaceProtocol
{

    override fun setMaskingObject(maskingObject: MapCoreSharedModule.MCMaskingObjectInterfaceProtocol?) {
        delegate.setMaskingObject(maskingObject?.let { (it as MapCoreSharedModule.MCMaskingObjectInterfaceProtocol).asKmp() })
    }

    override fun update() {
        delegate.update()
    }

    override fun buildRenderPasses(): List<*> {
        val result = delegate.buildRenderPasses()
        return ArrayList(result.map { it.asPlatform() })
    }

    override fun buildComputePasses(): List<*> {
        val result = delegate.buildComputePasses()
        return ArrayList(result.map { it.asPlatform() })
    }

    override fun onAdded(mapInterface: MapCoreSharedModule.MCMapInterface?, layerIndex: Int) {
        delegate.onAdded((mapInterface as MapCoreSharedModule.MCMapInterface).asKmp(), layerIndex)
    }

    override fun onRemoved() {
        delegate.onRemoved()
    }

    override fun pause() {
        delegate.pause()
    }

    override fun resume() {
        delegate.resume()
    }

    override fun hide() {
        delegate.hide()
    }

    override fun show() {
        delegate.show()
    }

    override fun setAlpha(alpha: Float) {
        delegate.setAlpha(alpha)
    }

    override fun getAlpha(): Float {
        val result = delegate.getAlpha()
        return result
    }

    override fun setScissorRect(scissorRect: MapCoreSharedModule.MCRectI?) {
        delegate.setScissorRect(scissorRect?.let { (it as MapCoreSharedModule.MCRectI).asKmp() })
    }

    override fun isReadyToRenderOffscreen(): MapCoreSharedModule.MCLayerReadyState {
        val result = delegate.isReadyToRenderOffscreen()
        return result.asPlatform()
    }

    override fun enableAnimations(enabled: Boolean) {
        delegate.enableAnimations(enabled)
    }

    override fun setErrorManager(errorManager: MapCoreSharedModule.MCErrorManager?) {
        delegate.setErrorManager((errorManager as MapCoreSharedModule.MCErrorManager).asKmp())
    }

    override fun forceReload() {
        delegate.forceReload()
    }

    override fun setPrimaryRenderTarget(target: MapCoreSharedModule.MCRenderTargetInterfaceProtocol?) {
        delegate.setPrimaryRenderTarget(target?.let { (it as MapCoreSharedModule.MCRenderTargetInterfaceProtocol).asKmp() })
    }
}

internal fun KMLayerInterface.asPlatform(): MapCoreSharedModule.MCLayerInterfaceProtocol = when (this) {
    is KMLayerInterfacePlatformWrapper -> this.nativeHandle
    else -> KMLayerInterfacePlatformProxy(this)
}
internal fun MapCoreSharedModule.MCLayerInterfaceProtocol.asKmp(): KMLayerInterface = KMLayerInterfacePlatformWrapper(this)
