// AUTOGENERATED FILE - DO NOT MODIFY!
// This file was generated by Djinni from core.djinni

@file:Suppress("RedundantCast", "RedundantCallOfConversionMethod", "USELESS_CAST")

package io.openmobilemaps.mapscore.kmp

import kotlin.experimental.ExperimentalObjCName
import kotlin.native.ObjCName
import platform.darwin.NSObject

@OptIn(ExperimentalObjCName::class)
@ObjCName("KMRendererInterface", exact = true)
actual interface KMRendererInterface
{

    actual fun addToRenderQueue(renderPass: KMRenderPassInterface)

    actual fun addToComputeQueue(computePass: KMComputePassInterface)

    actual fun drawFrame(renderingContext: KMRenderingContextInterface, camera: KMCameraInterface, target: KMRenderTargetInterface?)

    actual fun compute(renderingContext: KMRenderingContextInterface, camera: KMCameraInterface)
}

private class KMRendererInterfacePlatformWrapper(internal val nativeHandle: MapCoreSharedModule.MCRendererInterfaceProtocol) : KMRendererInterface
{

    override fun addToRenderQueue(renderPass: KMRenderPassInterface) {
        nativeHandle.addToRenderQueue(renderPass.asPlatform())
    }

    override fun addToComputeQueue(computePass: KMComputePassInterface) {
        nativeHandle.addToComputeQueue(computePass.asPlatform())
    }

    override fun drawFrame(renderingContext: KMRenderingContextInterface, camera: KMCameraInterface, target: KMRenderTargetInterface?) {
        nativeHandle.drawFrame(renderingContext.asPlatform(), camera.asPlatform(), target?.let { it.asPlatform() })
    }

    override fun compute(renderingContext: KMRenderingContextInterface, camera: KMCameraInterface) {
        nativeHandle.compute(renderingContext.asPlatform(), camera.asPlatform())
    }
}

private class KMRendererInterfacePlatformProxy(private val delegate: KMRendererInterface) : NSObject(), MapCoreSharedModule.MCRendererInterfaceProtocol
{

    override fun addToRenderQueue(renderPass: MapCoreSharedModule.MCRenderPassInterfaceProtocol?) {
        delegate.addToRenderQueue((renderPass as MapCoreSharedModule.MCRenderPassInterfaceProtocol).asKmp())
    }

    override fun addToComputeQueue(computePass: MapCoreSharedModule.MCComputePassInterfaceProtocol?) {
        delegate.addToComputeQueue((computePass as MapCoreSharedModule.MCComputePassInterfaceProtocol).asKmp())
    }

    override fun drawFrame(renderingContext: MapCoreSharedModule.MCRenderingContextInterfaceProtocol?, camera: MapCoreSharedModule.MCCameraInterfaceProtocol?, target: MapCoreSharedModule.MCRenderTargetInterfaceProtocol?) {
        delegate.drawFrame((renderingContext as MapCoreSharedModule.MCRenderingContextInterfaceProtocol).asKmp(), (camera as MapCoreSharedModule.MCCameraInterfaceProtocol).asKmp(), target?.let { (it as MapCoreSharedModule.MCRenderTargetInterfaceProtocol).asKmp() })
    }

    override fun compute(renderingContext: MapCoreSharedModule.MCRenderingContextInterfaceProtocol?, camera: MapCoreSharedModule.MCCameraInterfaceProtocol?) {
        delegate.compute((renderingContext as MapCoreSharedModule.MCRenderingContextInterfaceProtocol).asKmp(), (camera as MapCoreSharedModule.MCCameraInterfaceProtocol).asKmp())
    }
}

internal fun KMRendererInterface.asPlatform(): MapCoreSharedModule.MCRendererInterfaceProtocol = when (this) {
    is KMRendererInterfacePlatformWrapper -> this.nativeHandle
    else -> KMRendererInterfacePlatformProxy(this)
}
internal fun MapCoreSharedModule.MCRendererInterfaceProtocol.asKmp(): KMRendererInterface = KMRendererInterfacePlatformWrapper(this)
